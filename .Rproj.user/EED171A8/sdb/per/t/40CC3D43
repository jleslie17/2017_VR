{
    "collab_server" : "",
    "contents" : "# Use this script to match attendees based on knowledge, '3.1'\n\nsource('AddUnderscores.R')\nsource('SpreadResponses.R')\nlibrary(lsa)\nsource('GetMatches.R')\nsource('CompanyMatchesOutput.R')\n\npath <- getwd()\ndatadir <- paste(path, '/data/', sep = '')\n\n#Load and clean data\nFileMS2 <- 'Milestone2utf8.csv'\nFile130916 <- 'SSL_Reg_13.09.16.csv'\nFile190916 <- 'Registration19Sept.csv'\n\n\nData <- read.csv(paste(datadir, File190916, sep = ''),\n                 header = T, na.strings = '')\n\nData <- Data[rowSums(is.na(Data)) != ncol(Data),]\n\ndf <- Data[,21:33]\nnames(df)\n\ntargets <- df[,1:6]\nusers <- df[,8:13]\nnames(targets)\nnames(users)\n\n# Put underscores between words, but not between answers\ntargets <- AddUnderscores(targets)\n#Spread responses\ntarSpread <- SpreadResponses(targets)\nnames(tarSpread)\n# Remove columns with no predictive power\ndrops <- c('Other', 'na', 'N/A', '.*please.*select.*', 'NEED.*INFO',\n           'NEED_INFO', '---_please_select_---', 'n/a', '-', '.', 'none',\n           'X', 'None', 'N/a', 'No_interest', '%', 'n.a', 'tbc', 'n.a.', 'NA')\n\n#drops <- c('Other', 'na', 'N/A', '---_please_select_---')\ntarSpread <- tarSpread[, !names(tarSpread) %in% drops]\ncolSums(tarSpread)\nnames(tarSpread)\n\nCombineSimilarColumns <- function(df, a, b){\n        # Takes entries from column b and puts them into col a, then removes\n        # col b. Use this when two columns have slightly different names but\n        # tell the same information.\n        df[[a]][df[[b]] == 1] <- 1\n        df <- df[, names(df) != b]\n        return(df)\n}\n# Clean up tarSpread\nnames(tarSpread)[names(tarSpread) == 'wireless_connectivity'] <- 'Wireless_connectivity'\n\n\n\n\nusers <- AddUnderscores(users)\nusersSpread <- SpreadResponses(users)\nusersSpread <- usersSpread[, !names(usersSpread) %in% drops]\n# Tidy these due to bad formatting:\nnames(usersSpread)\nusersSpread <- usersSpread[,sort(names(usersSpread))]\ntarSpread <- tarSpread[,sort(names(tarSpread))]\n\n\nnames(usersSpread)\na <- 'Robotics_and_AI'\nb <- 'Robotics_and_AI_'\ntable(usersSpread[[a]])\ntable(usersSpread[[b]])\nusersSpread <- CombineSimilarColumns(usersSpread, a, b)\ntable(usersSpread[[a]])\ntable(usersSpread[[b]])\nnames(usersSpread)\n\n# usersSpread$Robotics_and_AI[usersSpread$Robotics_and_AI_ == 1] <- 1\n# usersSpread <- usersSpread[,names(usersSpread) != 'Robotics_and_AI_']\n#africa <- 'Smart_technology_African_cities'\n# names(tarSpread)[34] <- africa\n# names(usersSpread)[25] <- africa\n\na <- 'information_security'\nb <- 'inforamtion_security'\ntable(usersSpread[[a]])\ntable(usersSpread[[b]])\nusersSpread <- CombineSimilarColumns(usersSpread, a, b)\ntable(usersSpread[[a]])\ntable(usersSpread[[b]])\nnames(usersSpread)\n\na <- 'software_development'\nb <- 'Software'\ntable(usersSpread[[a]])\ntable(usersSpread[[b]])\nusersSpread <- CombineSimilarColumns(usersSpread, a, b)\ntable(usersSpread[[a]])\ntable(usersSpread[[b]])\nnames(usersSpread)\n\n\n# Now remove the columns in users that do not appear in targets\nnames(tarSpread)\nnames(usersSpread)\nnames(usersSpread)[!names(usersSpread) %in% names(tarSpread)]\nusersTidy <- usersSpread[,names(usersSpread) %in% names(tarSpread)]\nnames(tarSpread)\nnames(tarSpread)[!names(tarSpread) %in% names(usersTidy)]\ntarTidy <- tarSpread[,names(tarSpread) %in% names(usersTidy)]\n\n# Reorder the columns to match\n# index <- integer()\n# for(name in names(tarTidy)){\n#         index <- c(index, which(names(usersTidy) == name))\n# }\n# \n# names(usersTidy)[index]\n# names(tarTidy)\n# \n# identical(names(usersTidy)[index], names(tarTidy))\n# \n# usersTidy <- usersTidy[, index]\n\n# make empty matrix for for values to be added\nfor(i in 1:length(names(usersTidy))){\n        print(names(usersTidy)[i])\n        print(names(tarTidy)[i])\n}\n\nm <- matrix(0, nrow = nrow(usersSpread), ncol = nrow(tarSpread))\nmusers <- as.matrix(usersTidy)\nmtargets <- as.matrix(tarTidy)\n\ndistanceToTargets <- function(user, targets = mtargets){\n        distances <- numeric()\n        for(i in 1:nrow(targets)){\n                distances[i] <- cosine(user, targets[i,])\n        }\n        #This makes the outcome binary:\n        distances[is.na(distances)] <- 0\n        distances[distances > 0] <- 1\n        return(distances)\n}\n\n\nfor(i in 1:nrow(musers)){\n        m[i,] <- distanceToTargets(musers[i,])\n}\n\nmSum <- m + t(m)\n\nRankDistanceToTargets <- function(user, targets){\n        # Calculates cosine distance between one user profile and each of the\n        # targets in L. Returns only 25 best matches for the user. NOT the \n        # 25 best reciprocal fits!\n        tempDF <- data.frame(target = numeric(),\n                             distance = numeric())\n        distances <- numeric()\n        for(j in 1:length(targets)){\n                tempDF[j,1] <- targets[j]\n                tempDF[j,2] <- cosine(musers[user,], mtargets[targets[j],])\n        }\n        #This gives na the value of 0:\n        tempDF$distance[is.na(tempDF$distance)] <- 0\n        # Fills in the values up to position 25:\n        for(i in 1:25){\n                if(is.na(tempDF$distance[i])){\n                        tempDF[i,] <- 0\n                }\n        }\n        return(tempDF[order(tempDF$distance, decreasing = T)[1:25],1])\n}\n\nL <- list()\nfor(i in 1:nrow(mSum)){\n        x <- which(mSum[i,] > 1, arr.ind = T) #finds recipr matches\n        y <- x[x != i] #removes self\n        if(length(y) == 0){ #sets to 0 if no data\n                y <- 0\n                L[[i]] <- y\n        } else {\n                trimmed <- RankDistanceToTargets(i, y)\n                L[[i]] <- trimmed\n        }\n}\n\n# x <- which(mSum[1468,] > 1, arr.ind = T)\n# y <- x[x != 1468]\n# targets <- y\n# user <- 1468\n# \n# test <- y\n# for(i in 1:25){\n#         if(is.na(test[i])){\n#                 test[i] <- 0\n#         }\n# }\n# \n# RankDistanceToTargets[1468, y]\n\n# L is a list of matches\n# Here there is a list of matches. Now get that into suitable output\n# This puts the list of names of matches column-wise. Each column is\n# a delgate, with the rows being the matches. Not a great output.\nDelegatesToMeet <- GetMatches(L, Data)\n\n# This puts the data into a four-column dataframe, with the list of matches \n# as one \\n-separated string in the fourth column.\nKnowledgeMatchesOutput <- GetCompanyMatchesOutput(Data, DelegatesToMeet)\n\n#write.xlsx(KnowledgeMatchesOutput, 'KnowledgeMatchesTop25_M3.xlsx', row.names = F)\n",
    "created" : 1486051038777.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "313859192",
    "id" : "40CC3D43",
    "lastKnownWriteTime" : 1474315748,
    "last_content_update" : 1474315748,
    "path" : "~/Freelance/DataScience/MarkJohnstone/2017_VR/code/MatchingKnowledge.R",
    "project_path" : "code/MatchingKnowledge.R",
    "properties" : {
        "source_window_id" : "wjuco5yowf6g4"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}